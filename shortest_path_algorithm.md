# 1 路径规划概念

## 1.1 运动轨迹规划与路径规划区别

运动轨迹规划与路径规划是有所区别的，路径规划主要是生成从起点到终点不发生碰撞的静态几何轨线，不包含时间概念；而轨迹规划考虑时间因素，生成的不仅是轨迹，还包括车辆行驶速度、加速度、行驶时间和燃油消耗量等状态和控制参数。
车辆运动控制的主要任务是利用对车辆速度和方向的控制实现车辆位姿对规划轨迹的快速跟踪，并对车辆沿着规划轨迹行驶的状态和控制参数的响应参数进行闭环反馈，使得车辆能够准确沿着规划轨迹进行循迹行驶。

## 1.2 路径规划的定义
路径规划方法是在障碍物环境下，按照一定的评价标准规划出一条从起始状态(位置，姿态)到目标状态的无碰路径，主要考虑局部移动主体和障碍物之间的几何关系，找到一条不发生碰撞的路径。路径是一条静态的几何轨线，不包含时间概念，通常表示智能车辆在笛卡尔坐标下的位置和姿态关系。
根据智能车辆对环境信息掌握的程度，路径规划可以分为两种：

1. 环境信息完全已知的全局路径规划
2. 环境信息完全未知或部分未知，通过传感器在线对智能车辆的行驶环境进行感知，以获取障碍物的位置形状和尺寸等信息的局部路径规划

## 1.3  路径规划方法
在无人驾驶或者机器人路径规划总，路径规划其实在广义上分为两种：
1. 全局路径规划–这种路径规划就跟你在高德地图上的导航一样，规划了全局范围的、从起点到终点的行驶路径
2. 局部路径规划–在全局路径规划的基础上，当你想要躲避障碍物、变道、超车等等操作时，就会涉及到局部路径规划技术，通过局部路径规划，可以使得无人驾驶汽车更加平稳的度过这些操作

**global_planner**
A*、Dijstra、prm、人工势场、单元分解、快速搜索树（RRT）等

**local_planner**
eband_local_planner、asr_ftc_local_planner、dwa_local_planner、teb_local_planner

1. **模糊逻辑算法**
   模糊逻辑算法主要是对驾驶员的驾驶经验进行模拟，将驾驶员生理上的感知和行为动作进行结合，然后根据传感器提供的信息，通过查表可以得到规划轨迹的信息。
   该算法最符合人类的思维习惯和行为特点，能够很好的体现出跟人驾驶行为上的一致性。但是由于太过于模糊的设计函数，导致该方法主要依赖人的经验和试验，总结、量产十分困难。且一旦模糊规则制定后，再次想要调整起来困难重重。因此业界的主要用法都是讲其余其他逻辑方法相结合使用。

2. **基于行为的路径规划算法**
   基于行为的路径规划算法是把机器人需要完成的任务进行分解成一些简单的行为单位，机器人根据行为的优先级以及需要完成任务作出适当的反应。
   但是由于是对任务进行了分解，所以对于不同的行为来说需要完成不同的目标，不同的行为之间经常会产生冲突。此时就需要使用仲裁机制来对这些行为进行仲裁协调，谁先谁后。落实到具体操作上时，同一时刻只能有一个行为或者任务在被执行，行为按照不同的执行顺序组合成了一个完整的任务。
   该方法实时性很强，且非常灵活，但是缺点是在多种行为模式下，它的系统对于正确判断的概率会降低。

3. **基于再励学习的路径规划算法**
   基于再励学习的路径规划算法来源于行为心理学，用动物学习心理的“试错法”原理，对机器人在未知环境中移动的路径进行规划。
   此方法利用评价性反馈信号在与环境的交互反馈中进行学习，为实现智能系统的自学习能力提供有效手段。由于再励学习不需要先验知识和环境模型，也不需要样本训练数据，主要是通过与环境的直接交互进行学习，能够在线实现，所以对环境模型不确定的系统比较适用。但是此算法由于需要与环境进行直接交互，计算量较大。

4. **基于仿生学的路径优化算法**
   该方法准要是模拟一些生物上的生理特点进行的算法，如遗传算法、CNN、蚁群优化、栗子滤波等等。

# 2 常用路径规划算法

## 2.1 Dijkstra算法

Dijkstra算法是用来求加权图的单源最短路径算法之一，其实现方法有两种：动态规划和贪婪算法。

最短路径问题（Shortest Path Problem）是一类非常重要的问题，它出现在很多领域，例如车辆导航、路由选择、机器人运动规划、物流等。Dijkstra 算法是一种解决最短路径问题的经典算法，同时也是计算机科学中最有名的算法之一。其方法简洁，但蕴藏的思想却很深刻。通过学习 Dijkstra 算法，既可以掌握分析、解决问题的方法，也可以作为进一步学习其它搜索算法的基础。用一句时髦的话说，Dijkstra 算法——你值得拥有。 

算法简介：https://blog.csdn.net/robinvista/article/details/61421034

源码地址：https://github.com/KinsomyJS/dijkstra.git

![img](https://img-blog.csdn.net/20171210094550642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXNhc2FzYWFiYWJhYg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 2.2 AStar算法

 A*算法是启发式搜索，是一种尽可能基于现有信息的搜索策略，也就是说搜索过程中尽量利用目前已知的诸如迭代步数，以及从初始状态和当前状态到目标状态估计所需的费用等信息。

A*算法的核心是设计估价函数，设计估价函数h(j)有很多方法，下面介绍其中的两种：

1. 估价函数1：欧几里德距离（*这个估价函数的计算量很大，不利于海量数据的路径规划计算*）

2. 估价函数2：曼哈顿距离

算法原理详见：https://blog.csdn.net/tiandijun/article/details/62226163

Amit斯坦福大学一个博士的游戏网站：http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html#dijkstras-algorithm-and-best-first-search

算法比较：https://blog.csdn.net/qq_34446253/article/details/51427423

几个在线demo：
- https://anvaka.github.io/ngraph.path.demo/#?graph=amsterdam-roads
- http://qiao.github.io/PathFinding.js/visual/
- https://briangrinstead.com/files/astar/
- http://www.hightopo.com/demo/astar/astar.html

## 广度优先（BFS）和深度优先（DFS）搜索

在谈A*之前，还是要先聊聊搜索算法中的老祖宗，深度和广度优先搜索算法。这两个算法，基本上各教科书都会有讲解。
深度优先搜索，用俗话说就是不见棺材不回头。算法会朝一个方向进发，直到遇到边界或者障碍物，才回溯。一般在实现的时候，我们采用递归的方式来进行，也可以采用模拟压栈的方式来实现。

如下图，S代表起点，E代表终点。我们如果按照右、下、左、上这样的扩展顺序的话，算法就会一直往右扩张，直到走到地图的右边界，发现没找到目标点，然后再回溯。

![img](http://mmbiz.qpic.cn/mmbiz/YWnUbMibWJE1mEKHokribwic6wTBc4lzJ0XmdIBFAavylJGWMhaPf0hrZIbQzVIa9UkfZCjiaecED53x0Z6Eicq1zjw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这个算法的好处就是实现简单，可能就十几行代码。不过问题也很明显，就是：

1、路径可能不是最优解;

2、寻路时间比较长。

广度优先搜索，这个用形象的比喻，就像是地震波，从起点向外辐射，直到找到目标点。我们在实现的时候，一般采用队列来实现。

![img](http://mmbiz.qpic.cn/mmbiz/YWnUbMibWJE1mEKHokribwic6wTBc4lzJ0XxiayKJQicsKYVrXsicuTwJOxPsJqOzX8hg9TMDO0tHGnPm1OLViabIEzcA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这个算法的优点：

1、简单。代码也就几十行；

2、路径能找到最优解；

不足：

1、算法消耗的时间比较大，遍历的点会很多。

## Dijkstra 算法与A*算法的比较

Dijkstra 算法（没有使用启发式信息）

{ 绿色：起点       红色：终点       黑色：障碍物       白色：路径       黄色：已处理的节点 }

![img](https://img-blog.csdn.net/20161228204431629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iaW52aXN0YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

A* 算法（使用了启发式信息：到目标的距离）

![img](https://img-blog.csdn.net/20161228204449060?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iaW52aXN0YQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 2.3 DStar算法

D*是动态A*（D-Star, Dynamic A*） 卡耐基梅隆机器人中心的Stentz在1994和1995年的两篇文章提出，主要用于机器人探路。美国火星探测器上采用的就是此寻路算法。

## 2.4 PRM路径算法

随机路标图PRM算法，是一种基于图搜索的方法，它将连续空间转换成离散空间，再利用A*等搜索算法在路线图上寻找路径，以提高搜索效率。这种方法能用相对少的随机采样点来找到一个解，对多数问题而言，相对少的样本足以覆盖大部分可行的空间，并且找到路径的概率为1（随着采样数增加，P（找到一条路径）指数的趋向于1）。显然，当采样点太少，或者分布不合理时，PRM算法是不完备的，但是随着采用点的增加，也可以达到完备。所以PRM是概率完备且不最优的。

![img](https://img-blog.csdnimg.cn/20181221164939704)

## 2.5 路径平滑算法

常见的a*算法的结果是一串用来表示所经过的路径点坐标。但是这样的路径通常是有“锯齿”的，并不符合现实中的智能表现。因此，需要进一步的进行平滑处理，比如[ 佛洛依德算法](https://www.cnblogs.com/miaolegemi/archive/2017/12/05/7986335.html)。

## 2.6 RPT算法

传统的路径规划算法有人工势场法、模糊规则法、遗传算法、神经网络、模拟退火算法、蚁群优化算法等。但这些方法都需要在一个确定的空间内对障碍物进行建模，计算复杂度与机器人自由度呈指数关系，不适合解决多自由度机器人在复杂环境中的规划。基于快速扩展随机树（RRT / rapidly exploring random tree）的路径规划算法，通过对状态空间中的采样点进行碰撞检测，避免了对空间的建模，能够有效地解决高维空间和复杂约束的路径规划问题。该方法的特点是能够快速有效地搜索高维空间，通过状态空间的随机采样点，把搜索导向空白区域，从而寻找到一条从起始点到目标点的规划路径，适合解决多自由度机器人在复杂环境下和动态环境中的路径规划。与PRM类似，该方法是概率完备且不最优的。

![img](https://images2015.cnblogs.com/blog/890966/201701/890966-20170119115427765-1225467664.jpg)
